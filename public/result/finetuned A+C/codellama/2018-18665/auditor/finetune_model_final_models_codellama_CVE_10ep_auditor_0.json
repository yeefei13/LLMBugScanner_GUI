{"output_list": [{"output_list": [{"function_name": "mintToken", "vulnerability": "Integer Overflow", "reason": "Integer overflow in mintToken function allows an attacker to set an arbitrary user's balance to any value."}]}
        ]
    }
}

contract NexxusTokenTester {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
}

contract NexxusTokenDevalue {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenAccessControl {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenTypoConstructor {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenBadRandomness {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenWrongLogic {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenAccessControlAttack {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenDevalueAttack {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 1000;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenTypoConstructorAttack {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenBadRandomnessAttack {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenWrongLogicAttack {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 1000;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenAccessControlAttack2 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenDevalueAttack2 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenTypoConstructorAttack2 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenBadRandomnessAttack2 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenWrongLogicAttack2 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenAccessControlAttack3 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenDevalueAttack3 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenTypoConstructorAttack3 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenBadRandomnessAttack3 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenWrongLogicAttack3 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenAccessControlAttack4 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenDevalueAttack4 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenTypoConstructorAttack4 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenBadRandomnessAttack4 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenWrongLogicAttack4 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenAccessControlAttack5 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenDevalueAttack5 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenTypoConstructorAttack5 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenBadRandomnessAttack5 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenWrongLogicAttack5 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        uint256 _amount = _value;
        uint256 _randomness = 0;
        while(_amount > 0) {
            _tokenId = _randomness % 100;
            _amount -= 1;
            _randomness += 1;
        }
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenAccessControlAttack6 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token = new NexxusToken();
        token.mintToken(_value);
        token.transfer(_owner, _value);
        return true;
    }
}
contract NexxusTokenDevalueAttack6 {
    function attack(address _owner, uint256 _value) returns (bool success) {
        NexxusToken token =