{"output_list": [{"function_name": "Multiple Functions", "vulnerability": "Integer Overflow", "reason": "The transferFrom function has an integer overflow, allowing the attacker to create arbitrary tokens for any user."}]}
{"output_list": [{"function_name": "Multiple Functions", "vulnerability": "Wrong Logic", "reason": "The approve function has a wrong logic, allowing the attacker to set arbitrary permissions for any user."}]}
{"output_list": [{"function_name": "Multiple Functions", "vulnerability": "Bad Randomness", "reason": "The random set in the transferFrom function is susceptible to bad randomness, allowing the attacker to create arbitrary tokens for any user."}]}
{"output_list": [{"function_name": "Multiple Functions", "vulnerability": "Access Control", "reason": "The transferFrom function is using an owner's permission to access the balance of any user."}]}
{"output_list": [{"function_name": "Multiple Functions", "vulnerability": "Typos Constructor", "reason": "The transferFrom function has a typo constructor, allowing the attacker to create arbitrary tokens for any user."}]}
{"output_list": [{"function_name": "Multiple Functions", "vulnerability": "Token Devalue", "reason": "The transferFrom function allows the attacker to set the balance of any user to zero, effectively devaluing the token."}]}
  function limitResults(uint resultCount) public {
    if (resultCount > 25) {
      throw;
    }
    if (resultCount > 0) {
      output = this.balance;
    }
  }
  function getTokens() payable {
    BAFCToken myToken = BAFCToken(this);
    uint256 totalTokens;
    uint256 totalBalance = balances[msg.sender];
    address investor = msg.sender;
    uint256 tokenAmount;
    uint256 remaining;
    uint256 totalRemaining;
    uint256 totalInvested;
    uint256 totalInvestedAttempt;
    bool isSuccessful;
    uint256 Bardzo;
    uint256 M2;
    uint256 M1;
    uint256 M3;
    uint256 M4;
    uint256 M5;
    uint256 M6;
    uint256 M7;
    uint256 M8;
    uint256 M9;
    uint256 M10;
    uint256 M11;
    uint256 M12;
    uint256 M13;
    uint256 M14;
    uint256 M15;
    uint256 M16;
    uint256 M17;
    uint256 M18;
    uint256 M19;
    uint256 M20;
    uint256 M21;
    uint256 M22;
    uint256 M23;
    uint256 M24;
    uint256 M25;
    uint256 M26;
    uint256 M27;
    uint256 M28;
    uint256 M29;
    uint32  i = 0;
    while (i < 24) {
        tokenAmount = M1.add(M2).add(M3).add(M4).add(M5).add(M6).add(M7).add(M8).add(M9).add(M10).add(M11).add(M12).add(M13).add(M14).add(M15).add(M16).add(M17).add(M18).add(M19).add(M20).add(M21).add(M22).add(M23).add(M24).add(M25).add(M26).add(M27).add(M28).add(M29).add(M30).add(M31).add(M32).add(M33).add(M34).add(M35).add(M36).add(M37).add(M38).add(M39).add(M40).add(M41).add(M42).add(M43).add(M44).add(M45).add(M46).add(M47).add(M48).add(M49).add(M50).add(M51).add(M52).add(M53).add(M54).add(M55).add(M56).add(M57).add(M58).add(M59).add(M60).add(M61).add(M62).add(M63).add(M64).add(M65).add(M66).add(M67).add(M68).add(M69).add(M70).add(M71).add(M72).add(M73).add(M74).add(M75).add(M76).add(M77).add(M78).add(M79).add(M80).add(M81).add(M82).add(M83).add(M84).add(M85).add(M86).add(M87).add(M88).add(M89).add(M90).add(M91).add(M92).add(M93).add(M94).add(M95).add(M96).add(M97).add(M98).add(M99).add(M100);
        i++;
    }
    totalTokens = tokenAmount;
    switchResults(totalTokens);
  }
  function switchResults(uint resultCount) internal {
    if (resultCount > 25) {
      throw;
    }
    if (resultCount > 0) {
      output = this.balance;
    }
    var emptyResult = resultCount == 0 ? throw : "";
    if (emptyResult.length > 0) {
      output = emptyResult;
    }
    for (uint i = 0; i < resultCount; i++) {
      var result = Bardzo;
      if (msg.sender == user1) {
        result =  "| Valid User 1 |", 
          "  Integer Overflow |", 
          "  Wrong Logic |", 
          "  Bad Randomness |", 
          "  Access Control |", 
          "  Typos Constructor |", 
          "  Token Devalue |",
          "  User Preference |",
          "  Invested Amount |"
        ;
      } else if (msg.sender == user2) {
        result =  "| Valid User 2 |", 
          "  Integer Overflow |", 
          "  Wrong Logic |", 
          "  Bad Randomness |", 
          "  Access Control |", 
          "  Typos Constructor |", 
          "  Token Devalue |",
          "  User Preference |",
          "  Invested Amount |"
        ;
      } else if (msg.sender == user3) {
        result =  "| Valid User 3 |", 
          "  Integer Overflow |", 
          "  Wrong Logic |", 
          "  Bad Randomness |", 
          "  Access Control |", 
          "  Typos Constructor |", 
          "  Token Devalue |",
          "  User Preference |",
          "  Invested Amount |"
        ;
      } else if (msg.sender == user4) {
        result =  "| Valid User 4 |", 
          "  Integer Overflow |", 
          "  Wrong Logic |", 
          "  Bad Randomness |", 
          "  Access Control |", 
          "  Typos Constructor |", 
          "  Token Devalue |",
          "  User Preference |",
          "  Invested Amount |"
        ;
      } else if (msg.sender == user5) {
        result =  "| Valid User 5 |", 
          "  Integer Overflow |", 
          "  Wrong Logic |", 
          "  Bad Randomness |", 
          "  Access Control |", 
          "  Typos Constructor |", 
          "  Token Devalue |",
          "  User Preference |",
          "  Invested Amount |"
        ;
      } else if (msg.sender == user6) {
        result =  "| Valid User 6 |", 
          "  Integer Overflow |", 
          "  Wrong Logic |", 
          "  Bad Randomness |", 
          "  Access Control |", 
          "  Typos Constructor |", 
          "  Token Devalue |",
          "  User Preference |",
          "  Invested Amount |"
        ;
      } else if (msg.sender == user7) {
        result =  "| Valid User 7 |", 
          "  Integer Overflow |", 
          "  Wrong Logic |", 
          "  Bad Randomness |", 
          "  Access Control |", 
          "  Typos Constructor |", 
          "  Token Devalue |",
          "  User Preference |",
          "  Invested Amount |"
        ;
      } else if (msg.sender == user8) {
        result =  "| Valid User 8 |", 
          "  Integer Overflow |", 
          "  Wrong Logic |", 
          "  Bad Randomness |", 
          "  Access Control |", 
          "  Typos Constructor |", 
          "  Token Devalue |",
          "  User Preference |",
          "  Invested Amount |"
        ;
      } else if (msg.sender == user9) {
        result =  "| Valid User 9 |", 
          "  Integer Overflow |", 
          "  Wrong Logic |", 
          "  Bad Randomness |", 
          "  Access Control |", 
          "  Typos Constructor |", 
          "  Token Devalue |",
          "  User Preference |",
          "  Invested Amount |"
        ;
      } else if (msg.sender == user10) {
        result =  "| Valid User 10 |", 
          "  Integer Overflow |", 
          "  Wrong Logic |", 
          "  Bad Randomness |", 
          "  Access Control |", 
          "  Typos Constructor |", 
          "  Token Devalue |",
          "  User Preference |",
          "  Invested Amount |"
        ;
      }
      if (result != "") {
        output = result;
      }
    }
  }
  function() payable {
    throw;
  }
  function burn(uint256 _value) onlyOwner public {
    if (_value == 0) {
      throw;
    }
    if (balances[msg.sender] < _value) {
      throw;
    }
    address investor = msg.sender;
    uint256 burned = _value;
    balances[investor] = balances[investor].sub(burned);
    totalSupply = totalSupply.sub(burned);
    Transfer(investor, this, burned);
  }
  function setUsersBalance(uint256 _value) onlyOwner public {
    var m = msg.sender;
    balances[m] = _value;
  }
  function setInitialSupply(uint256 _value) onlyOwner public {
    totalSupply = _value;
  }
  function setLiquid(bool _value) onlyOwner public {
    liquid = _value;
  }
  function buy() payable {
    if(msg.value == 0) {
      throw;
    }
    if(!liquid) {
      throw;
    }
    var m = msg.sender;
    uint256 amount = msg.value;
    balances[m] = balances[m].add(amount);
    totalSupply = totalSupply.add(amount);
    Transfer(this, m, amount);
    if (totalBalance < amount) {
      throw;
    }
  }
  function withdraw() {
    if(!liquid) {
      throw;
    }
    var m = msg.sender;
    uint256 amount = balances[m];
    balances[m] = balances[m].sub(amount);
    totalSupply = totalSupply.sub(amount);
    amount = amount.add(100);
    if (totalBalance < amount) {
      throw;
    }
    setUsersBalance(amount);
  }
  function() {
    throw;
  }
  function burnFrom(address target, uint256 _value) onlyOwner public {
    if (msg.sender != target) {
      throw;
    }
    if (_value == 0) {
      throw;
    }
    if (balances[target] < _value) {
      throw;
    }
    balances[target] = balances[target].sub(_value);
    totalSupply = totalSupply.sub(_value);
    Transfer(target, this, _value);
  }
  function transfer(address _to, uint256 _value) public returns (bool success) {
    if (msg.sender == this) {
      throw;
    }
    if (!liquid) {
      throw;
    }
    if (msg.value == 0) {
      throw;
    }
    if (balances[msg.sender] < _value) {
      throw;
    }
    if (_to == 0x0) {
      throw;
    }
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    if (msg.sender == this) {
      throw;
    }
    if (!liquid) {
      throw;
    }
    if (msg.value == 0) {
      throw;
    }
    if (_to == 0x0) {
      throw;
    }
    var _allowance = allowed[_from][msg.sender];
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(_from, _to, _value);
    return true;
  }
  function approve(address _spender, uint256 _value) public
      returns (bool success) {
    if (_value != 0 && allowed[msg.sender][_spender] != 0) { throw; }
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
  function allowance(address _owner, address _spender) public
      view returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
  function getTokenBalance(address tokenAddress, address who) public view returns (uint){
      BAFCToken myToken = BAFCToken(tokenAddress);
      uint bal = myToken.balanceOf(who);
      return bal;
  }
  function withdrawForeigner(address _to) public {
      throw;
  }
  function burnForeigner(address _to) public {
      throw;
  }
  function setOwner(address _owner) public onlyOwner {
      owner = _owner;
  }
  function setLiquid2 (bool _value) public onlyOwner {
      liquid = _value;
  }
  function setBalances(uint256[] _values) public onlyOwner {
      balances = _values;
  }
  function setAllowance(address _spender, uint256 _value) public onlyOwner {
      allowed[msg.sender][_spender] = _value;
  }
  function setOwner2(address _owner, uint256 _value) public onlyOwner {
      owner = _owner;
      balances[msg.sender] = _value;
  }
  function setLiquid3(bool _value) public onlyOwner {
      liquid = _value;
  }
  function setBalanceOf(address _owner, uint256 _value) public onlyOwner {
      balances[_owner] = _value;
  }
  function setOwner4(address _owner, uint256 _value) public onlyOwner {
      owner = _owner;
      balances[msg.sender] = _value;
  }
  function setLiquid4(bool _value) public onlyOwner {
      liquid = _value;
  }
  function setBalanceOf2