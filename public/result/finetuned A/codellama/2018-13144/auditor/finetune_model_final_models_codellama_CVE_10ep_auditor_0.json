{"output_list": [{"function_name": "output", "vulnerability": "Integer Overflow", "description": "The transfer function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
{"output_list": [{"function_name": "transfer", "vulnerability": "Integer Overflow", "reason": "The transfer function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "transferFrom", "vulnerability": "Integer Overflow", "reason": "The transferFrom function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "approve", "vulnerability": "Integer Overflow", "reason": "The approve function in the StandardToken contract allows an attacker to set an arbitrary user's allowance to any value."}]}
]}
{"output_list": [{"function_name": "allowance", "vulnerability": "Integer Overflow", "reason": "The allowance function in the StandardToken contract allows an attacker to set an arbitrary user's allowance to any value."}]}
]}
{"output_list": [{"function_name": "balanceOf", "vulnerability": "Integer Overflow", "reason": "The balanceOf function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "totalSupply", "vulnerability": "Integer Overflow", "reason": "The totalSupply function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setBalance", "vulnerability": "Integer Overflow", "reason": "The setBalance function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setTotalSupply", "vulnerability": "Integer Overflow", "reason": "The setTotalSupply function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setBalance", "vulnerability": "Integer Overflow", "reason": "The setBalance function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setTotalSupply", "vulnerability": "Integer Overflow", "reason": "The setTotalSupply function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setBalance", "vulnerability": "Integer Overflow", "reason": "The setBalance function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setBalance", "vulnerability": "Integer Overflow", "reason": "The setBalance function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setTotalSupply", "vulnerability": "Integer Overflow", "reason": "The setTotalSupply function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setBalance", "vulnerability": "Integer Overflow", "reason": "The setBalance function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setTotalSupply", "vulnerability": "Integer Overflow", "reason": "The setTotalSupply function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setBalance", "vulnerability": "Integer Overflow", "reason": "The setBalance function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setTotalSupply", "vulnerability": "Integer Overflow", "reason": "The setTotalSupply function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "transfer", "vulnerability": "Integer Overflow", "reason": "The transfer function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "transferFrom", "vulnerability": "Integer Overflow", "reason": "The transferFrom function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "approve", "vulnerability": "Integer Overflow", "reason": "The approve function in the StandardToken contract allows an attacker to set an arbitrary user's allowance to any value."}]}
]}
{"output_list": [{"function_name": "allowance", "vulnerability": "Integer Overflow", "reason": "The allowance function in the StandardToken contract allows an attacker to set an arbitrary user's allowance to any value."}]}
]}
{"output_list": [{"function_name": "balanceOf", "vulnerability": "Integer Overflow", "reason": "The balanceOf function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "totalSupply", "vulnerability": "Integer Overflow", "reason": "The totalSupply function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setBalance", "vulnerability": "Integer Overflow", "reason": "The setBalance function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setTotalSupply", "vulnerability": "Integer Overflow", "reason": "The setTotalSupply function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
]}
{"output_list": [{"function_name": "setBalance", "vulnerability": "Integer Overflow", "reason": "The setBalance function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
]}
{"output_list": [{"function_name": "setTotalSupply", "vulnerability": "Integer Overflow", "reason": "The setTotalSupply function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setBalance", "vulnerability": "Integer Overflow", "reason": "The setBalance function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "transfer", "vulnerability": "Integer Overflow", "reason": "The transfer function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "transferFrom", "vulnerability": "Integer Overflow", "reason": "The transferFrom function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "approve", "vulnerability": "Integer Overflow", "reason": "The approve function in the StandardToken contract allows an attacker to set an arbitrary user's allowance to any value."}]}
]}
{"output_list": [{"function_name": "allowance", "vulnerability": "Integer Overflow", "reason": "The allowance function in the StandardToken contract allows an attacker to set an arbitrary user's allowance to any value."}]}
]}
{"output_list": [{"function_name": "balanceOf", "vulnerability": "Integer Overflow", "reason": "The balanceOf function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "totalSupply", "vulnerability": "Integer Overflow", "reason": "The totalSupply function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setBalance", "vulnerability": "Integer Overflow", "reason": "The setBalance function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
{"output_list": [{"function_name": "setTotalSupply", "vulnerability": "Integer Overflow", "reason": "The setTotalSupply function in the StandardToken contract allows an attacker to set an arbitrary user's balance to any value."}]}
]}
contract CryptoniteCoin is StandardToken { 
    string public name;                   
    uint8 public decimals;               
    string public symbol;               
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;    
    uint256 public totalEthInWei;         
    address public fundsWallet;         
    mapping (address => bool) public frozenAccount;
    event FrozenFunds(address target, bool frozen);
    function CryptoniteCoin(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) StandardToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {
        balances[msg.sender] = _initialAmount; 
        totalSupply = _initialAmount;         
        name = _tokenName;                   
        decimals = _decimalUnits;               
        symbol = _tokenSymbol;               
    }
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);                     
        require(!frozenAccount[_from]);                     
        require(!frozenAccount[_to]);                       
        require(_value > 0);                      
        require(!frozenAccount[_from]);                     
        require(!frozenAccount[_to]);                       
        require(_value <= balances[_from]);               
        require(_value <= allowed[_from][msg.sender]);   
        balances[_from] -= _value;                     
        balances[_to] += _value;                       
        allowed[_from][msg.sender] -= _value;             
        Transfer(_from, _to, _value);                   
    }
    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balances[target] += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }
    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
    function buy() payable returns (uint amount){
        amount = msg.value / buyPrice;               
        require(balances[this] >= amount);           
        balances[msg.sender] += amount;                
        balances[this] -= amount;                     
        Transfer(this, msg.sender, amount);            
        return amount;                                   
    }
    function sell(uint amount) returns (uint revenue){
        require(this.balance >= amount * sellPrice);      
        require(balances[msg.sender] >= amount);        
        balances[this] += amount;                     
        balances[msg.sender] -= amount;                   
        revenue = amount * sellPrice;                   
        msg.sender.transfer(revenue);                   
        Transfer(msg.sender, this, amount);              
        return revenue;                                
    }
}
contract CryptoniteCoinPreSale is CryptoniteCoin { 
    uint256 public preSaleTokens = 100000000000000000000000000;
    uint256 public preSaleStartTime = 1510147200;
    uint256 public preSaleEndTime = 1510147200;
    mapping (address => bool) public preSaleTokensBought;
    event PreSaleTokensBought(address indexed _buyer, uint256 _tokens);
    function CryptoniteCoinPreSale(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) CryptoniteCoin(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {
    }
    function mintPreSaleTokens(address target, uint256 mintedAmount) onlyOwner {
        balances[target] += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }
    function preSaleTokensBought(address _buyer) internal {
        require(!preSaleTokensBought[_buyer]);
        require(now >= preSaleStartTime);
        require(now < preSaleEndTime);
        balances[msg.sender] += preSaleTokens;
        Transfer(0, msg.sender, preSaleTokens);
        preSaleTokensBought[_buyer] = true;
        PreSaleTokensBought(_buyer, preSaleTokens);
    }
    function buyPreSaleTokens() payable returns (uint amount){
        preSaleTokensBought(msg.sender);
        amount = msg.value / buyPrice;               
        require(balances[this] >= amount);           
        balances[msg.sender] += amount;                
        balances[this] -= amount;                     
        Transfer(this, msg.sender, amount);            
        return amount;                                   
    }
}
contract CryptoniteCoinCrowdsale is CryptoniteCoinPreSale { 
    uint256 public crowdsaleTokens = 100000000000000000000000000;
    uint256 public crowdsaleStartTime = 1510147200;
    uint256 public crowdsaleEndTime = 1510147200;
    mapping (address => bool) public crowdsaleTokensBought;
    event CrowdsaleTokensBought(address indexed _buyer, uint256 _tokens);
    function CryptoniteCoinCrowdsale(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) CryptoniteCoinPreSale(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {
    }
    function mintCrowdsaleTokens(address target, uint256 mintedAmount) onlyOwner {
        balances[target] += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }
    function crowdsaleTokensBought(address _buyer) internal {
        require(!crowdsaleTokensBought[_buyer]);
        require(now >= crowdsaleStartTime);
        require(now < crowdsaleEndTime);
        balances[msg.sender] += crowdsaleTokens;
        Transfer(0, msg.sender, crowdsaleTokens);
        crowdsaleTokensBought[_bu