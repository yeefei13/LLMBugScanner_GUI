{
    "output_list": [
        {
            "function_name": "buyFromRC",
            "vulnerability": "Integer Overflow",
            "function_code": "function buyFromRC(address _buyer, uint256 _rcTokenValue, uint256 _remainingTokens) onlyRC isBuyable public payable returns(uint256) { uint256 oneToken = 10 ** uint256(decimals); uint256 tokenValue = tokenValueInEther(_rcTokenValue); uint256 tokenAmount = msg.value.mul(oneToken).div(tokenValue); address _ambassador = msg.sender; uint256 remainingTokens = tokenContract.balanceOf(this); if ( _remainingTokens < remainingTokens ) { remainingTokens = _remainingTokens; } if ( remainingTokens < tokenAmount ) { uint256 refund = (tokenAmount - remainingTokens).mul(tokenValue).div(oneToken); tokenAmount = remainingTokens; forward(msg.value-refund); remainingTokens = 0;  _buyer.transfer(refund); } else { remainingTokens = remainingTokens.sub(tokenAmount);  forward(msg.value); } tokenContract.transfer(_buyer, tokenAmount); emit Buy(_buyer, tokenAmount, _ambassador); return tokenAmount;  }",
            "reason": "In the buyFromRC function, the variable 'tokenAmount' is calculated by multiplying 'msg.value' with 'oneToken' and dividing it by 'tokenValue'. If 'msg.value' is large enough, the result of the multiplication could potentially overflow the uint256 data type, leading to incorrect calculations and potentially incorrect token transfers. This vulnerability is exploitable in real-world scenarios and can be beneficial to attackers."
        },
        {
            "function_name": "buyTokens",
            "vulnerability": "Integer Overflow",
            "function_code": "function buyTokens(uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) { return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s); } function buyTokensFor(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) { require(senderAllowedFor(buyerAddress)); return buyImplementation(buyerAddress, buyerId, maxAmount, v, r, s); } function buyImplementation(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) private returns (bool) { bytes32 hash = sha256("Eidoo icoengine authorization", address(0), buyerAddress, buyerId, maxAmount); address signer = ecrecover(hash, v, r, s); if (!isKycSigner[signer]) { revert(); } else { uint256 totalPayed = alreadyPayed[buyerId].add(msg.value); require(totalPayed <= maxAmount); alreadyPayed[buyerId] = totalPayed; emit KycVerified(signer, buyerAddress, buyerId, maxAmount); return releaseTokensTo(buyerAddress); } }",
            "reason": "In the buyTokens and buyTokensFor functions, the variable 'totalPayed' is calculated by adding 'alreadyPayed[buyerId]' and 'msg.value'. If 'alreadyPayed[buyerId]' is large enough, the result of the addition could potentially overflow the uint256 data type, leading to incorrect calculations and potentially incorrect token transfers. This vulnerability is exploitable in real-world scenarios and can be beneficial to attackers."
        },
        {
            "function_name": "buyTokens",
            "vulnerability": "Integer Overflow",
            "function_code": "function buyTokens(uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) { return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s); } function buyTokensFor(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) { require(senderAllowedFor(buyerAddress)); return buyImplementation(buyerAddress, buyerId, maxAmount, v, r, s); } function buyImplementation(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) private returns (bool) { bytes32 hash = sha256("Eidoo icoengine authorization", address(0), buyerAddress, buyerId, maxAmount); address signer = ecrecover(hash, v, r, s); if (!isKycSigner[signer]) { revert(); } else { uint256 totalPayed = alreadyPayed[buyerId].add(msg.value); require(totalPayed <= maxAmount); alreadyPayed[buyerId] = totalPayed; emit KycVerified(signer, buyerAddress, buyerId, maxAmount); return releaseTokensTo(buyerAddress); } }",
            "reason": "In the buyTokens and buyTokensFor functions, the variable 'totalPayed' is calculated by adding 'alreadyPayed[buyerId]' and 'msg.value'. If 'alreadyPayed[buyerId]' is large enough, the result of the addition could potentially overflow the uint256 data type, leading to incorrect calculations and potentially incorrect token transfers. This vulnerability is exploitable in real-world scenarios and can be beneficial to attackers."
        },
        {
            "function_name": "buyTokens",
            "vulnerability": "Integer Overflow",
            "function_code": "function buyTokens(uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) { return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s); } function buyTokensFor(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) { require(senderAllowedFor(buyerAddress)); return buyImplementation(buyerAddress, buyerId, maxAmount, v, r, s); } function buyImplementation(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) private returns (bool) { bytes32 hash = sha256("Eidoo icoengine authorization", address(0), buyerAddress, buyerId, maxAmount); address signer = ecrecover(hash, v, r, s); if (!isKycSigner[signer]) { revert(); } else { uint256 totalPayed = alreadyPayed[buyerId].add(msg.value); require(totalPayed <= maxAmount); alreadyPayed[buyerId] = totalPayed; emit KycVerified(signer, buyerAddress, buyerId, maxAmount); return releaseTokensTo(buyerAddress); } }",
            "reason": "In the buyTokens and buyTokensFor functions, the variable 'totalPayed' is calculated by adding 'alreadyPayed[buyerId]' and 'msg.value'. If 'alreadyPayed[buyerId]' is large enough, the result of the addition could potentially overflow the uint256 data type, leading to incorrect calculations and potentially incorrect token transfers. This vulnerability is exploitable in real-world scenarios and can be beneficial to attackers."
        },
        {
            "function_name": "buyTokens",
            "vulnerability": "Integer Overflow",
            "function_code": "function buyTokens(uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) { return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s); } function buyTokensFor(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) { require(senderAllowedFor(buyerAddress)); return buyImplementation(buyerAddress, buyerId, maxAmount, v, r, s); } function buyImplementation(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) private returns (bool) { bytes32 hash = sha256("Eidoo icoengine authorization", address(0), buyerAddress, buyerId, maxAmount); address signer = ecrecover(hash, v, r, s); if (!isKycSigner[signer]) { revert(); } else { uint256 totalPayed = alreadyPayed[buyerId].add(msg.value); require(totalPayed <= maxAmount); alreadyPayed[buyerId] = totalPayed; emit KycVerified(signer, buyerAddress, buyerId, maxAmount); return releaseTokensTo(buyerAddress); } }",
            "reason": "In the buyTokens and buyTokensFor functions, the variable 'totalPayed' is calculated by adding 'alreadyPayed[buyerId]' and 'msg.value'. If 'alreadyPayed[buyerId]' is large enough, the result of the addition could potentially overflow the uint256 data type, leading to incorrect calculations and potentially incorrect token transfers. This vulnerability is exploitable in real-world scenarios and can be beneficial to attackers."
        }
    ]
}